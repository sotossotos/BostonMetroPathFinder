% CS308 - Group W12

# Usage

Make a JAR using `make jar`. Run the JAR using `./run bostonmetro.txt`.

Other options:

- `make docs`:
    - outputs the design docs at `design.pdf`.
    - outputs the API docs at `build/docs/`.
- `make jar` runs `ant build-jar`.
- `ant compile` compiles the application.
- `ant test` runs the tests.
- `ant build-jar` creates a jar in `.build/metro.jar`.
- `ant clean` cleans all build files.

# Description and requirements

- The graph will always be undirected.
- All weights are equal.
- We have to find the shortest route with the minimum label changes. But shorter is prioritized.
- Modifying or deleting edges is not required.
- Classes/interfaces for nodes and edges are required.
- Edges and nodes don't need to be generic.
- Breadth-first search algorithm.

# Changes in the design

We were suggested to add an interface and a concrete class representing the
nodes in our graph. The rationale behind this is that, even if in our graph
nodes could be represented by mere unique identifiers, having a dedicated type,
even if it is just a type synonym, makes the API types more expressive and the
overall design clearer.

Whatever uses our `Multigraph` interface, it has to be able to create nodes and
edges to append them to the graph. But nodes and edges can only be created using
concrete classes. Using those directly would make the user of the `Multigraph`
interface dependent on the concrete classes. So we needed to add some
`createNode` and `createEdge` methods to our interface which would be
implemented using whatever concrete classes the concrete multigraph class
depended on.

The downside of this is that the API gets less pleasant to use, as adding an
edge to the graph requires to:

    n1 = multigraph.createNode(identifier1, name1);
    n2 = multigraph.createNode(identifier2, name2);
    e1 = multigraph.createEdge(n1, n2, label1);
    multigraph.addEdge(e1);

As opposed to:

    multigraph.addEdge(identifier1, identifier2, label1);

Of course, the `addEdge` method could be overloaded to allow this. But that
would break the conceptual gain of having an interface representing nodes.

## Metro System

The initial design was lacking the Metro System package compared to the final 
product. The main reason is at that time the group hasn't developed or thought 
throw the design of the project.

# Interfaces, classes and methods

Refer to the javadocs. They can be generated by running `make docs` or `ant docs`.

The UML class diagram can be found in `metroUMLdiagram.svg`.

## Underlying data structure

We decided to use a hashmap as the underlying data structure for our graphs.
Each node `n` in the graph is a key in the map and has as value the set all
edges for which `n` is the start node. This effectively means that all the edges
in the graph are indexed by their start node. This allows us to:

- Perform efficient (log n) queries to get the edges that come out from a node.
- Handle directed graphs.
- Handle undirected graphs - by adding edges and their reversions.
- Handle nodes that are not connected by any edges.

# Search algorithm

- Uses breadth-first search.
- Considers unevaluated nodes in incremental batches.
- When the end node is found, its batch is marked as the last one.
- Thus finds all the possible paths of length `n` where `n` is the shortest
  length possible.
- Annotates the edges that got us to a particular node.
- Uses those annotations for backtracking.
- Selects the path with less changes in edge labels from amongst the shortest
  paths.

# UML Diagram

![UML diagram](metroUMLdiagram.png)
